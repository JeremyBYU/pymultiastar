{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Multi-Goal A-star","text":"<p>This repo contains code to search for multiple goals with heterogenous values using a 3D A-star discrete planner. The majority of the code is written in C++ with Python bindings. This planner was used in the paper Map-Based Planning for Small Unmanned Aircraft Rooftop Landing</p> <p>What do you mean by discrete?</p> <p>The map provided should be a 3D voxel grid(i, j, k), a 3D NumPy array, which the planner searches. A cell with the value 0.0 is considered free space. A cell with the value 1.0 is considered an obstacle and cannot be traversed (this value is configurable). Values between 0.0 and 1.0 can be traversed but with a penalty (penalty weight is configurable).</p> <p>What do you mean by multiple goals with heterogenous values?</p> <p>A normal A-star planner has a start location and one goal. This Multi-Goal planner allows you to provide multiple goal cells each having different values. Goals with lower values are more desirable. This planner will try to find the optimal goal and path which minimizes an objective function. It must be understood that the planner doesn't just find a path. It finds the one goal and the corresponding optimal path that minimizes some larger objective function. </p> <p>What is the larger objective function?</p> <p>The objective function is the minimization of total risk ($r_t$), which is the combination of path risk ($r_p$) and goal risk $r_g$. In my research the goals were landing sites, therefore I called the latter landing site risk $r_l$.  Below is an excerpt from my paper that discusses this trade-off between objectives:</p> <pre><code>The figure below shows an example Pareto frontier that minimizes two objectives: landing\nsite risk and path risk. Each purple dot represents a landing site. The x-axis represents\nlanding site risk and the y-axis represents path risk to that site. The green line\nconnects five points on the Pareto frontier, the set of non-dominated landing sites\nfor which any improvement in one objective results in a negative trade-off in the other.\nEach of these five landing sites is \u201coptimal\u201d, and a quantifiable relationship between\neach objective must be constructed to select a final choice. A linear weighting scheme\nis used for these purposes\n</code></pre> <p>$$ r_t = w_l \\cdot r_l + w_p \u00b7 r_p $$</p> <p></p> <p>Given the weighting between the two objectives, one of the purple dots on the green line is considered the \"best\" goal/path pair and will have minimum total risk. Here's the kicker though: you do not know the path risk until you do path planning. However, path planning is very expensive. PyMultiAStar will search for the optimal goal/path such that we minimize our expensive path planning procedures, often only needing to perform path planning 1-3 times on average.</p> <p>How do you minimize path planning? How do you know when to stop searching?</p> <p>We first sort the goals by their minimum total risk $r_{t,min}$ where</p> <p>$$r_{t,min} = w_{g} \\cdot r_{g} + w_p \\cdot  h(\\mathbf{start}, \\mathbf{goal}) / R$$</p> <p>where $h$ is an admissible heuristic and $R$ is a normalizing constant. Basically, we are bounding the minimum path distance which in turn bounds total risk. $R$ is usually the largest distance permissible during path planning. This entire list is very cheap to compute and sort.</p> <p>The first goal in this sorted list is the most likely to be the lowest total risk, but we don't know until we do path planning. After path planning to this goal, we can determine the true path risk and calculate the total risk. If the goal's total risk is less than the next goal's minimum total risk, we can guarantee we found the optimal solution to our objective function. We can stop searching! </p> <p>What precisely are these objectives and where are the details of the planner?</p> <p>See the following sections in the paper linked above: </p> <ul> <li>Definition of Path Cost: Section 1.3.2, Equations 1.6-1.8</li> <li>Definition of Path Risk: Section 1.5, Equation 1.17</li> <li>Definition of Landing Site (Goal) Risk: Section 1.4.4, Equation 1.9. This can be defined as anything for your specific problem.</li> <li>Definition of Total Risk: Section 1.6.2, Equation 1.18. </li> <li>Proof of Planner: Section 1.6.3</li> </ul>"},{"location":"#install","title":"Install","text":"<p>Binary Wheels are provided for you on <code>PyPi</code>:</p> <ol> <li>Discrete Multi-Goal Planner - <code>pip install pymultiastar</code> - This exposes the class <code>PyMultiAStar</code><ol> <li>This planner only knows about Voxel Grid to traverse.</li> </ol> </li> <li>Geographically Aware Planner - <code>pip install pymultiastar[geo]</code> - This also exposes the class <code>GeoPlanner</code><ol> <li>This is a geographically aware wrapper around <code>PyMultiAStar</code>. You give a georeferenced voxel map and start conditions in GPS and landing sites in GPS and it will do the conversions between GPS to voxel cell for you. </li> </ol> </li> </ol>"},{"location":"#how-to-use","title":"How to use","text":"<p>Below are some examples:</p> <ol> <li><code>run_simple_world_3d.py</code>. Shows a very simple example of a small 3D world with multiple goals.</li> <li><code>run_maze_2d.py</code> - Demonstrates that 2D A-star path planning is a subset of the Multi-Goal Planner. It loads a 2D image of a maze as a single slice in a 3D world and has only 1 goal. </li> <li><code>run_scenarios.py</code> - Shows how to use the GeoPlanner and plan in a 3D world.</li> </ol>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p>"},{"location":"contributing/#environment-setup","title":"Environment setup","text":"<p>Nothing easier!</p> <p>Fork and clone the repository, then:</p> <pre><code>cd pymultiastar\npip install -e \".[dev]\"\n</code></pre>"},{"location":"contributing/#development","title":"Development","text":"<p>As usual:</p> <ol> <li>create a new branch: <code>git checkout -b feature-or-bugfix-name</code></li> <li>edit the code and/or the documentation</li> </ol> <p>Then create a pull request!</p>"},{"location":"license/","title":"License","text":"<pre><code>MIT License\n\nCopyright (c) 2023 Jeremy Castagno\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"reference/","title":"pymultiastar","text":""},{"location":"reference/#pymultiastar._core.PyMultiAStar","title":"<code>pymultiastar._core.PyMultiAStar()</code>","text":"<p>A planner that will search for multiple goals with heterogenous values using a 3D A-star discrete planner.</p> <p>Parameters:</p> Name Type Description Default <code>map</code> <code>ArrayFloatMxNxK</code> <p>3D NumPy array, often called the voxel grid.                    index (i,j,k) corresponds to (y, x, z)</p> required <code>allow_diag</code> <code>bool</code> <p>Allows diagonal travel in map. Defaults to False.</p> <code>False</code> <code>map_res</code> <code>float</code> <p>The length (m) of an edge in the voxel grid. Defaults to 2.0.</p> <code>2.0</code> <code>obstacle_value</code> <code>float</code> <p>The value of an obstacle in the map. Defaults to 1.0.</p> <code>1.0</code> <code>normalizing_path_cost</code> <code>float</code> <p>The length and penalities of a path must                                     be normalized. This should generally be the                                     the longest path acceptable. Defaults to 1.0.</p> <code>1.0</code> <code>goal_weight</code> <code>float</code> <p>The weighting of the goal risk. Defaults to 0.5.</p> <code>0.5</code> <code>path_weight</code> <code>float</code> <p>The weighting of the path risk. Defaults to 0.5.</p> <code>0.5</code> <code>keep_nodes</code> <code>bool</code> <p>An optimization parameter which, if set to True,                          may result in less dynamic memory allocations if many                          goals are being searched for. Defaults to False.</p> <code>False</code> <code>path_w0</code> <code>float</code> <p>The path cost penalty multiplier when encountering                         a potential field. Defaults to 1.0.</p> <code>1.0</code>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.search_multiple","title":"<code>search_multiple()</code>  <code>method descriptor</code>","text":"<p>Will search though the map finding the optimal goal/path pair.</p> <p>Parameters:</p> Name Type Description Default <code>start_cell</code> <code>Cell</code> <p>The start voxel cell in the map</p> required <code>goal_cells</code> <code>List[Tuple[Cell, float]]</code> <p>A list of goal cells and their                                     corresponding goal risk</p> required <p>Returns:</p> Type Description <code>Tuple[CellPath, MultiPlannerResult]</code> <p>Tuple[CellPath, MultiPlannerResult]: The cell path and full planner results</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.search_single","title":"<code>search_single()</code>  <code>method descriptor</code>","text":"<p>Single A* search</p> <p>Parameters:</p> Name Type Description Default <code>start_cell</code> <code>Cell</code> <p>Start Cell</p> required <code>goal_cells</code> <code>Cell</code> <p>End Cell</p> required <p>Returns:</p> Type Description <code>Tuple[CellPath, float]</code> <p>Tuple[CellPath, float]: Path and Path Cost</p>"},{"location":"reference/types/","title":"types","text":""},{"location":"reference/geoplanner/","title":"geoplanner","text":""},{"location":"reference/geoplanner/#pymultiastar.geoplanner.GPS","title":"<code>GPS</code>  <code>dataclass</code>","text":""},{"location":"reference/geoplanner/#pymultiastar.geoplanner.types.GPS.from_gps_string","title":"<code>from_gps_string(centroid, alt=np.nan, reverse=False)</code>  <code>staticmethod</code>","text":"<p>Converts a lat-long string to a GPS object. Optionally handles height and projection</p> Source code in <code>C:\\Users\\Jerem\\scoop\\apps\\mambaforge\\current\\envs\\aclm\\lib\\site-packages\\pymultiastar\\geoplanner\\types.py</code> <pre><code>@staticmethod\ndef from_gps_string(centroid: str, alt=np.nan, reverse=False):\n\"\"\"Converts a lat-long string to a GPS object. Optionally handles height and projection\"\"\"\n    centroid_ = centroid.split(\",\")\n    # reverse lat,lon if necessary\n    if reverse:\n        centroid_ = centroid_[::-1]\n    gps = GPS(float(centroid_[0]), float(centroid_[1]), alt=alt)\n    return gps\n</code></pre>"},{"location":"reference/geoplanner/#pymultiastar.geoplanner.GeoPlanner","title":"<code>GeoPlanner(cost_map_fp, voxel_meta, planner_kwargs=PlannerKwargs())</code>","text":"<p>         Bases: <code>object</code></p> <p>Geographic Planner</p> <p>Parameters:</p> Name Type Description Default <code>cost_map_fp</code> <code>Path</code> <p>File path to your 3D numpy array of your cost map</p> required <code>voxel_meta</code> <code>VoxelMeta</code> <p>All meta data concerning the voxel cost_map</p> required <code>planner_kwargs</code> <code>PlannerKwargs</code> <p>Key word arguments sent to the multi-goal a-star planner. Defaults to PlannerKwargs().</p> <code>PlannerKwargs()</code> Source code in <code>C:\\Users\\Jerem\\scoop\\apps\\mambaforge\\current\\envs\\aclm\\lib\\site-packages\\pymultiastar\\geoplanner\\geoplanner.py</code> <pre><code>def __init__(\n    self,\n    cost_map_fp: Path,\n    voxel_meta: VoxelMeta,\n    planner_kwargs: PlannerKwargs = PlannerKwargs(),\n):\n\"\"\"GeoPlanner Constructor\n\n    Args:\n        cost_map_fp (Path): File path to your 3D numpy array of your cost map\n        voxel_meta (VoxelMeta): All meta data concerning the voxel cost_map\n        planner_kwargs (PlannerKwargs, optional): Key word arguments sent to the\n            multi-goal a-star planner. Defaults to PlannerKwargs().\n    \"\"\"\n    self.cost_map: ArrayFloatMxNxK = np.load(Path(cost_map_fp))\n    self.voxel_meta = voxel_meta\n    self.planner_kwargs = planner_kwargs\n\n    self.cost_map = convert_cost_map_to_float(np.load(cost_map_fp))\n    self.planner = pmstar.PyMultiAStar(self.cost_map, **planner_kwargs.to_dict())\n\n    self.transformer = Transformer.from_crs(\n        \"EPSG:4326\", voxel_meta[\"srid\"]\n    )\n</code></pre>"},{"location":"reference/geoplanner/#pymultiastar.geoplanner.geoplanner.GeoPlanner.cost_map","title":"<code>cost_map: ArrayFloatMxNxK = convert_cost_map_to_float(np.load(cost_map_fp))</code>  <code>instance-attribute</code>","text":"<p>A 3D numpy array of shape (M,N,K) of type float. Our voxel map</p>"},{"location":"reference/geoplanner/#pymultiastar.geoplanner.geoplanner.GeoPlanner.planner","title":"<code>planner: pmstar.PyMultiAStar = pmstar.PyMultiAStar(self.cost_map, None=planner_kwargs.to_dict())</code>  <code>instance-attribute</code>","text":"<p>The multi-goal a-star planner</p>"},{"location":"reference/geoplanner/#pymultiastar.geoplanner.geoplanner.GeoPlanner.planner_kwargs","title":"<code>planner_kwargs: PlannerKwargs = planner_kwargs</code>  <code>instance-attribute</code>","text":"<p>The planner keyword arguments sent to pymultiastar</p>"},{"location":"reference/geoplanner/#pymultiastar.geoplanner.geoplanner.GeoPlanner.voxel_meta","title":"<code>voxel_meta: VoxelMeta = voxel_meta</code>  <code>instance-attribute</code>","text":"<p>All metadata concerning the voxel cost_map, e.g. srid, nrows, ncols, xres, etc.</p>"},{"location":"reference/geoplanner/#pymultiastar.geoplanner.geoplanner.GeoPlanner.plan_multi_goal","title":"<code>plan_multi_goal(start_position, ls_list)</code>","text":"<p>Will find the optimal landing site and path pair from a start position</p> <p>Parameters:</p> Name Type Description Default <code>start_position</code> <code>GPS</code> <p>The start position of the aircraft</p> required <code>ls_list</code> <code>List[LandingSite]</code> <p>A list of landing sites with the associated risk</p> required <p>Returns:</p> Name Type Description <code>GeoMultiPlannerResult</code> <code>Optional[GeoMultiPlannerResult]</code> <p>The result of the planner</p> Source code in <code>C:\\Users\\Jerem\\scoop\\apps\\mambaforge\\current\\envs\\aclm\\lib\\site-packages\\pymultiastar\\geoplanner\\geoplanner.py</code> <pre><code>def plan_multi_goal(\n    self, start_position: GPS, ls_list: List[LandingSite]\n) -&gt; Optional[GeoMultiPlannerResult]:\n\"\"\"Will find the optimal landing site and path pair from a start position\n\n    Args:\n        start_position (GPS): The start position of the aircraft\n        ls_list (List[LandingSite]): A list of landing sites with the associated risk\n\n    Returns:\n        GeoMultiPlannerResult: The result of the planner\n    \"\"\"\n\n    project_start, projected_goals = prepare_planning_args_optimized(\n        start_position, ls_list, self.transformer\n    )\n    # to cell position\n    start_cell = voxel_projected_to_cell(project_start, self.voxel_meta)      \n    # logger.debug(f\"Start Cell: {start_cell}\")\n    goal_cells:List[Tuple[Tuple[int, int, int], float]] = []\n\n    # Checking on start and goal cell positions\n    bad_start = self.cost_map[start_cell[0], start_cell[1], start_cell[2]] == np.inf\n    if bad_start:\n        sc_ = start_cell[:]  # makes copy\n        start_cell = get_free_neighbor_cell(start_cell, self.cost_map)\n        if start_cell is None:\n            logger.error(\n                \"ERROR - Bad Start Cell! Start Cell: {} - {}\".format(\n                    sc_, self.cost_map[sc_[0], sc_[1], sc_[2]]\n                )\n            )\n            logger.error(\"{}\".format(start_position))\n            return None\n    # This set is used to ensure that every goal as a UNIQUE cell location in the voxel grid.\n    unique_goal_cell_set = set()\n    # In case a bad goal has been give, keep this list to mark all the valid goals (landing sites)\n    valid_landing_site_indices:List[int] = []\n    for i, (goal_pos, goal_value) in enumerate(projected_goals):\n        gc = voxel_projected_to_cell(goal_pos, self.voxel_meta)\n        bad_goal = self.cost_map[gc[0], gc[1], gc[2]] == np.inf\n        if bad_goal:\n            gc_ = gc[:]  # makes copy\n            # looks at neighbors around the cell\n            gc = get_free_neighbor_cell(gc, self.cost_map)\n            if gc is None:\n                # last chance, going vertically up only!\n                gc = get_first_free_cell_up(gc_, self.voxel_meta, self.cost_map)\n                if gc is None:\n                    # Wow this was a really bad goal.  Log the issue an review later\n                    logger.error(\n                        \"ERROR - Bad Goal Cell! Start Cell: {} - {}. Goal Cell: {} - {}\".format(\n                            start_cell,\n                            self.cost_map[\n                                start_cell[0], start_cell[1], start_cell[2]\n                            ],\n                            gc_,\n                            self.cost_map[gc_[0], gc_[1], gc_[2]],\n                        )\n                    )\n                    logger.error(\"{}, {}\".format(start_position, goal_pos))\n                    continue\n        if str(gc) not in unique_goal_cell_set:\n            unique_goal_cell_set.add(str(gc))\n            valid_landing_site_indices.append(i)\n            goal_cells.append((gc, goal_value))\n        else:\n            logger.error(\n                \"Landing site is mapped to a Map Cell that is already taken! Skipping. Index: %r, Pos: %r, Value: %r\",\n                i,\n                goal_pos,\n                goal_value,\n            )\n\n    logger.debug(f\"Start Cell: {start_cell}\")\n    logger.debug(f\"Goal Cells: {goal_cells}\")\n\n    start_time = time.perf_counter()\n    path_cells, meta = self.planner.search_multiple(\n        start_cell, goal_cells\n    )\n    elapsed_time = (time.perf_counter() - start_time) * 1000\n\n    if meta[\"goal_total_cost\"] == -1.0:\n        logger.error(\n            \"Could not find path! Starting UTM: %r; Starting Cell: %r\",\n            start_position,\n            start_cell,\n        )\n\n    logger.debug(\"Path Cost: %s \", meta[\"goal_total_cost\"])\n    # These are index coordinates! Convert to meters\n    path_projected = [\n        voxel_cell_to_projected(cell, self.voxel_meta)\n        for cell in path_cells\n    ]\n    path_projected_zero_origin = [\n        self.transform_projected_to_zero_origin(coord)\n        for coord in path_projected\n    ]\n\n\n    path_length = get_path_dist(path_projected)\n    # {'path_cost': dummy_path_risk(start_pos, goal_pos), 'path': path, 'index': index}\n    result:GeoMultiPlannerResult = {\n        \"start_position\": start_position,\n        \"path_cells\": path_cells,\n        \"path_projected\": path_projected,\n        \"path_projected_zero_origin\": path_projected_zero_origin,\n        \"path_length\": path_length,\n        \"time_ms\": elapsed_time,\n        \"valid_landing_site_indices\": valid_landing_site_indices,\n        **meta,\n    }\n    return result\n</code></pre>"},{"location":"reference/geoplanner/#pymultiastar.geoplanner.LandingSite","title":"<code>LandingSite</code>  <code>dataclass</code>","text":"<p>         Bases: <code>SuperDataClass</code></p>"},{"location":"reference/geoplanner/#pymultiastar.geoplanner.types.LandingSite.centroid","title":"<code>centroid: GPS</code>  <code>instance-attribute</code>","text":"<p>The centroid of the landing site in GPS coordinates</p>"},{"location":"reference/geoplanner/#pymultiastar.geoplanner.types.LandingSite.landing_site_risk","title":"<code>landing_site_risk: float</code>  <code>instance-attribute</code>","text":"<p>The normalized risk of this landing site [0-1]</p>"},{"location":"reference/geoplanner/geoplanner/","title":"geoplanner","text":""},{"location":"reference/geoplanner/geoplanner/#pymultiastar.geoplanner.geoplanner.GeoPlanner","title":"<code>GeoPlanner(cost_map_fp, voxel_meta, planner_kwargs=PlannerKwargs())</code>","text":"<p>         Bases: <code>object</code></p> <p>Geographic Planner</p> <p>Parameters:</p> Name Type Description Default <code>cost_map_fp</code> <code>Path</code> <p>File path to your 3D numpy array of your cost map</p> required <code>voxel_meta</code> <code>VoxelMeta</code> <p>All meta data concerning the voxel cost_map</p> required <code>planner_kwargs</code> <code>PlannerKwargs</code> <p>Key word arguments sent to the multi-goal a-star planner. Defaults to PlannerKwargs().</p> <code>PlannerKwargs()</code> Source code in <code>C:\\Users\\Jerem\\scoop\\apps\\mambaforge\\current\\envs\\aclm\\lib\\site-packages\\pymultiastar\\geoplanner\\geoplanner.py</code> <pre><code>def __init__(\n    self,\n    cost_map_fp: Path,\n    voxel_meta: VoxelMeta,\n    planner_kwargs: PlannerKwargs = PlannerKwargs(),\n):\n\"\"\"GeoPlanner Constructor\n\n    Args:\n        cost_map_fp (Path): File path to your 3D numpy array of your cost map\n        voxel_meta (VoxelMeta): All meta data concerning the voxel cost_map\n        planner_kwargs (PlannerKwargs, optional): Key word arguments sent to the\n            multi-goal a-star planner. Defaults to PlannerKwargs().\n    \"\"\"\n    self.cost_map: ArrayFloatMxNxK = np.load(Path(cost_map_fp))\n    self.voxel_meta = voxel_meta\n    self.planner_kwargs = planner_kwargs\n\n    self.cost_map = convert_cost_map_to_float(np.load(cost_map_fp))\n    self.planner = pmstar.PyMultiAStar(self.cost_map, **planner_kwargs.to_dict())\n\n    self.transformer = Transformer.from_crs(\n        \"EPSG:4326\", voxel_meta[\"srid\"]\n    )\n</code></pre>"},{"location":"reference/geoplanner/geoplanner/#pymultiastar.geoplanner.geoplanner.GeoPlanner.cost_map","title":"<code>cost_map: ArrayFloatMxNxK = convert_cost_map_to_float(np.load(cost_map_fp))</code>  <code>instance-attribute</code>","text":"<p>A 3D numpy array of shape (M,N,K) of type float. Our voxel map</p>"},{"location":"reference/geoplanner/geoplanner/#pymultiastar.geoplanner.geoplanner.GeoPlanner.planner","title":"<code>planner: pmstar.PyMultiAStar = pmstar.PyMultiAStar(self.cost_map, None=planner_kwargs.to_dict())</code>  <code>instance-attribute</code>","text":"<p>The multi-goal a-star planner</p>"},{"location":"reference/geoplanner/geoplanner/#pymultiastar.geoplanner.geoplanner.GeoPlanner.planner_kwargs","title":"<code>planner_kwargs: PlannerKwargs = planner_kwargs</code>  <code>instance-attribute</code>","text":"<p>The planner keyword arguments sent to pymultiastar</p>"},{"location":"reference/geoplanner/geoplanner/#pymultiastar.geoplanner.geoplanner.GeoPlanner.voxel_meta","title":"<code>voxel_meta: VoxelMeta = voxel_meta</code>  <code>instance-attribute</code>","text":"<p>All metadata concerning the voxel cost_map, e.g. srid, nrows, ncols, xres, etc.</p>"},{"location":"reference/geoplanner/geoplanner/#pymultiastar.geoplanner.geoplanner.GeoPlanner.plan_multi_goal","title":"<code>plan_multi_goal(start_position, ls_list)</code>","text":"<p>Will find the optimal landing site and path pair from a start position</p> <p>Parameters:</p> Name Type Description Default <code>start_position</code> <code>GPS</code> <p>The start position of the aircraft</p> required <code>ls_list</code> <code>List[LandingSite]</code> <p>A list of landing sites with the associated risk</p> required <p>Returns:</p> Name Type Description <code>GeoMultiPlannerResult</code> <code>Optional[GeoMultiPlannerResult]</code> <p>The result of the planner</p> Source code in <code>C:\\Users\\Jerem\\scoop\\apps\\mambaforge\\current\\envs\\aclm\\lib\\site-packages\\pymultiastar\\geoplanner\\geoplanner.py</code> <pre><code>def plan_multi_goal(\n    self, start_position: GPS, ls_list: List[LandingSite]\n) -&gt; Optional[GeoMultiPlannerResult]:\n\"\"\"Will find the optimal landing site and path pair from a start position\n\n    Args:\n        start_position (GPS): The start position of the aircraft\n        ls_list (List[LandingSite]): A list of landing sites with the associated risk\n\n    Returns:\n        GeoMultiPlannerResult: The result of the planner\n    \"\"\"\n\n    project_start, projected_goals = prepare_planning_args_optimized(\n        start_position, ls_list, self.transformer\n    )\n    # to cell position\n    start_cell = voxel_projected_to_cell(project_start, self.voxel_meta)      \n    # logger.debug(f\"Start Cell: {start_cell}\")\n    goal_cells:List[Tuple[Tuple[int, int, int], float]] = []\n\n    # Checking on start and goal cell positions\n    bad_start = self.cost_map[start_cell[0], start_cell[1], start_cell[2]] == np.inf\n    if bad_start:\n        sc_ = start_cell[:]  # makes copy\n        start_cell = get_free_neighbor_cell(start_cell, self.cost_map)\n        if start_cell is None:\n            logger.error(\n                \"ERROR - Bad Start Cell! Start Cell: {} - {}\".format(\n                    sc_, self.cost_map[sc_[0], sc_[1], sc_[2]]\n                )\n            )\n            logger.error(\"{}\".format(start_position))\n            return None\n    # This set is used to ensure that every goal as a UNIQUE cell location in the voxel grid.\n    unique_goal_cell_set = set()\n    # In case a bad goal has been give, keep this list to mark all the valid goals (landing sites)\n    valid_landing_site_indices:List[int] = []\n    for i, (goal_pos, goal_value) in enumerate(projected_goals):\n        gc = voxel_projected_to_cell(goal_pos, self.voxel_meta)\n        bad_goal = self.cost_map[gc[0], gc[1], gc[2]] == np.inf\n        if bad_goal:\n            gc_ = gc[:]  # makes copy\n            # looks at neighbors around the cell\n            gc = get_free_neighbor_cell(gc, self.cost_map)\n            if gc is None:\n                # last chance, going vertically up only!\n                gc = get_first_free_cell_up(gc_, self.voxel_meta, self.cost_map)\n                if gc is None:\n                    # Wow this was a really bad goal.  Log the issue an review later\n                    logger.error(\n                        \"ERROR - Bad Goal Cell! Start Cell: {} - {}. Goal Cell: {} - {}\".format(\n                            start_cell,\n                            self.cost_map[\n                                start_cell[0], start_cell[1], start_cell[2]\n                            ],\n                            gc_,\n                            self.cost_map[gc_[0], gc_[1], gc_[2]],\n                        )\n                    )\n                    logger.error(\"{}, {}\".format(start_position, goal_pos))\n                    continue\n        if str(gc) not in unique_goal_cell_set:\n            unique_goal_cell_set.add(str(gc))\n            valid_landing_site_indices.append(i)\n            goal_cells.append((gc, goal_value))\n        else:\n            logger.error(\n                \"Landing site is mapped to a Map Cell that is already taken! Skipping. Index: %r, Pos: %r, Value: %r\",\n                i,\n                goal_pos,\n                goal_value,\n            )\n\n    logger.debug(f\"Start Cell: {start_cell}\")\n    logger.debug(f\"Goal Cells: {goal_cells}\")\n\n    start_time = time.perf_counter()\n    path_cells, meta = self.planner.search_multiple(\n        start_cell, goal_cells\n    )\n    elapsed_time = (time.perf_counter() - start_time) * 1000\n\n    if meta[\"goal_total_cost\"] == -1.0:\n        logger.error(\n            \"Could not find path! Starting UTM: %r; Starting Cell: %r\",\n            start_position,\n            start_cell,\n        )\n\n    logger.debug(\"Path Cost: %s \", meta[\"goal_total_cost\"])\n    # These are index coordinates! Convert to meters\n    path_projected = [\n        voxel_cell_to_projected(cell, self.voxel_meta)\n        for cell in path_cells\n    ]\n    path_projected_zero_origin = [\n        self.transform_projected_to_zero_origin(coord)\n        for coord in path_projected\n    ]\n\n\n    path_length = get_path_dist(path_projected)\n    # {'path_cost': dummy_path_risk(start_pos, goal_pos), 'path': path, 'index': index}\n    result:GeoMultiPlannerResult = {\n        \"start_position\": start_position,\n        \"path_cells\": path_cells,\n        \"path_projected\": path_projected,\n        \"path_projected_zero_origin\": path_projected_zero_origin,\n        \"path_length\": path_length,\n        \"time_ms\": elapsed_time,\n        \"valid_landing_site_indices\": valid_landing_site_indices,\n        **meta,\n    }\n    return result\n</code></pre>"},{"location":"reference/geoplanner/helper/","title":"helper","text":""},{"location":"reference/geoplanner/helper/#pymultiastar.geoplanner.helper.convert_cost_map_to_float","title":"<code>convert_cost_map_to_float(cost_map, reverse_yaxis=True, normalize=True, set_max_value_to_inf=True)</code>","text":"<p>Will convert a uint8 cost map to a float32</p> <p>Note, the normal expectation is that the dimension are like so [y, x, z] Also the y-axis is growing DOWN, like an image, if this was generated from https://bitbucket.org/umich_a2sys/create-voxel/src/master/</p> <p>Parameters:</p> Name Type Description Default <code>cost_map</code> <code>np.ndarray</code> <p>Three dimensional cost map</p> required <code>reverse_yaxis</code> <code>bool</code> <p>Will reverse y axes of the map. Defaults to True.</p> <code>True</code> <code>normalize</code> <code>bool</code> <p>Will normalize cost from 0 to 1.0. Defaults to True.</p> <code>True</code> <code>set_max_value_to_inf</code> <code>bool</code> <p>All max values will be mapped to np.inf. Defaults True.</p> <code>True</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>np.ndarray: Your 3D cost map in float32</p> Source code in <code>C:\\Users\\Jerem\\scoop\\apps\\mambaforge\\current\\envs\\aclm\\lib\\site-packages\\pymultiastar\\geoplanner\\helper.py</code> <pre><code>def convert_cost_map_to_float(\n    cost_map, reverse_yaxis=True, normalize=True, set_max_value_to_inf=True\n) -&gt; np.ndarray:\n\"\"\"Will convert a uint8 cost map to a float32\n\n\n    Note, the normal expectation is that the dimension are like so [y, x, z]\n    Also the y-axis is growing DOWN, like an image, if this was generated from https://bitbucket.org/umich_a2sys/create-voxel/src/master/\n\n\n    Args:\n        cost_map (np.ndarray): Three dimensional cost map\n        reverse_yaxis (bool, optional): Will reverse y axes of the map. Defaults to True.\n        normalize (bool, optional): Will normalize cost from 0 to 1.0. Defaults to True.\n        set_max_value_to_inf (bool, optional): All max values will be mapped to np.inf. Defaults True.\n\n    Returns:\n        np.ndarray: Your 3D cost map in float32\n    \"\"\"\n    cost_map = cost_map.astype(np.float32)\n    if reverse_yaxis:\n        cost_map = np.flip(cost_map, 0)  # reverses the y-axis\n    if normalize:\n        max_value = np.max(cost_map)\n        cost_map = cost_map / max_value  # convert to float32\n    if set_max_value_to_inf:\n        cost_map[cost_map == 1.0] = np.inf\n    return cost_map\n</code></pre>"},{"location":"reference/geoplanner/helper/#pymultiastar.geoplanner.helper.prepare_planning_args_optimized","title":"<code>prepare_planning_args_optimized(start_position, ls_list, transformer)</code>","text":"<p>Prepares a list of landing sites formatted as a dictionary to be sent to a Path Planner Data is in x, y, height all in meters</p> Source code in <code>C:\\Users\\Jerem\\scoop\\apps\\mambaforge\\current\\envs\\aclm\\lib\\site-packages\\pymultiastar\\geoplanner\\helper.py</code> <pre><code>def prepare_planning_args_optimized(\n    start_position: GPS, ls_list: List[LandingSite], transformer: Transformer\n):\n\"\"\"Prepares a list of landing sites formatted as a dictionary to be sent to a Path Planner\n    Data is in x, y, height all in meters\"\"\"\n    projected_position: Tuple[float, float, float] = transformer.transform(\n        *start_position.to_array()\n    )\n    projected_goal_positions: List[Tuple[Tuple[float, float, float], float]] = [\n        (transformer.transform(*ls.centroid.to_array()), ls.landing_site_risk)\n        for ls in ls_list\n    ]\n\n    return projected_position, projected_goal_positions\n</code></pre>"},{"location":"reference/geoplanner/types/","title":"types","text":""},{"location":"reference/geoplanner/types/#pymultiastar.geoplanner.types.GPS","title":"<code>GPS</code>  <code>dataclass</code>","text":""},{"location":"reference/geoplanner/types/#pymultiastar.geoplanner.types.GPS.from_gps_string","title":"<code>from_gps_string(centroid, alt=np.nan, reverse=False)</code>  <code>staticmethod</code>","text":"<p>Converts a lat-long string to a GPS object. Optionally handles height and projection</p> Source code in <code>C:\\Users\\Jerem\\scoop\\apps\\mambaforge\\current\\envs\\aclm\\lib\\site-packages\\pymultiastar\\geoplanner\\types.py</code> <pre><code>@staticmethod\ndef from_gps_string(centroid: str, alt=np.nan, reverse=False):\n\"\"\"Converts a lat-long string to a GPS object. Optionally handles height and projection\"\"\"\n    centroid_ = centroid.split(\",\")\n    # reverse lat,lon if necessary\n    if reverse:\n        centroid_ = centroid_[::-1]\n    gps = GPS(float(centroid_[0]), float(centroid_[1]), alt=alt)\n    return gps\n</code></pre>"},{"location":"reference/geoplanner/types/#pymultiastar.geoplanner.types.LandingSite","title":"<code>LandingSite</code>  <code>dataclass</code>","text":"<p>         Bases: <code>SuperDataClass</code></p>"},{"location":"reference/geoplanner/types/#pymultiastar.geoplanner.types.LandingSite.centroid","title":"<code>centroid: GPS</code>  <code>instance-attribute</code>","text":"<p>The centroid of the landing site in GPS coordinates</p>"},{"location":"reference/geoplanner/types/#pymultiastar.geoplanner.types.LandingSite.landing_site_risk","title":"<code>landing_site_risk: float</code>  <code>instance-attribute</code>","text":"<p>The normalized risk of this landing site [0-1]</p>"},{"location":"reference/visualization/","title":"visualization","text":""},{"location":"reference/visualization/img2d_helpers/","title":"img2d_helpers","text":""},{"location":"reference/visualization/img2d_helpers/#pymultiastar.visualization.img2d_helpers.get_maze","title":"<code>get_maze(img_path, offset=3)</code>","text":"<p>This will load an image of maze into a 3D numpy array</p> <p>Parameters:</p> Name Type Description Default <code>img_path</code> <code>Path</code> <p>Path to img holding maze</p> required <code>offset</code> <code>int</code> <p>Where to offset to start and finish. Defaults to 3.</p> <code>3</code> <p>Returns:</p> Name Type Description <code>MazeReturn</code> <code>MazeReturn</code> <p>Returns a dictionary of maze data</p> Source code in <code>C:\\Users\\Jerem\\scoop\\apps\\mambaforge\\current\\envs\\aclm\\lib\\site-packages\\pymultiastar\\visualization\\img2d_helpers.py</code> <pre><code>def get_maze(img_path: Path, offset=3) -&gt; MazeReturn:\n\"\"\"This will load an image of maze into a 3D numpy array\n\n    Args:\n        img_path (Path): Path to img holding maze\n        offset (int, optional): Where to offset to start and finish. Defaults to 3.\n\n    Returns:\n        MazeReturn: Returns a dictionary of maze data\n    \"\"\"\n    img:np.ndarray = np.asarray(Image.open(img_path))\n    logger.debug(f\"Maze name: {img_path.name}, Shape: {img.shape}\")\n    logger.debug(f\"Unique values: {np.unique(img)}\")\n    # convert to float and an empty third dimension\n    img_f:np.ndarray = np.expand_dims((img / np.max(img)).astype(np.float32), axis=2)\n    # Best case scenario is a diagonal path, lets guess it will be 50% bigger\n    normalizing_path_cost:float = 1.5 * np.sqrt(img.shape[0] ** 2 + img.shape[1] ** 2)\n    return MazeReturn(\n        img=img,\n        map=img_f,\n        normalizing_path_cost=normalizing_path_cost,\n    )\n</code></pre>"},{"location":"reference/visualization/img2d_helpers/#pymultiastar.visualization.img2d_helpers.write_path_to_maze","title":"<code>write_path_to_maze(img_path, path, width=1)</code>","text":"<p>This will write the solution of the maze as a red line</p> <p>Parameters:</p> Name Type Description Default <code>img_path</code> <code>Path</code> <p>Original image of the maze</p> required <code>path</code> <code>np.array</code> <p>Solution path through the maze</p> required Source code in <code>C:\\Users\\Jerem\\scoop\\apps\\mambaforge\\current\\envs\\aclm\\lib\\site-packages\\pymultiastar\\visualization\\img2d_helpers.py</code> <pre><code>def write_path_to_maze(img_path: Path, path:np.array, width=1):\n\"\"\"This will write the solution of the maze as a red line\n\n    Args:\n        img_path (Path): Original image of the maze\n        path (np.array): Solution path through the maze\n    \"\"\"\n    new_img_path = img_path.with_name(img_path.stem + \"_solution.png\")\n    shutil.copy(img_path, new_img_path)\n    path = path[:, :2]\n    path = np.flip(path, axis=1) # the \"map\" has the row dimension as the first dimension (because images..)\n    path = list(map(tuple, path))\n    with Image.open(new_img_path).convert('RGB') as im:\n        draw = ImageDraw.Draw(im)\n        draw.line(path, fill=(255,0,0), width=width)\n        im.save(new_img_path)\n\n    return new_img_path\n</code></pre>"},{"location":"reference/visualization/vis3d_helpers/","title":"vis3d_helpers","text":""},{"location":"reference/visualization/vis3d_helpers/#pymultiastar.visualization.vis3d_helpers.is_pareto_efficient","title":"<code>is_pareto_efficient(costs)</code>","text":"<p>:param costs: An (n_points, n_costs) array :return: A (n_points, ) boolean array, indicating whether each point is Pareto efficient</p> Source code in <code>C:\\Users\\Jerem\\scoop\\apps\\mambaforge\\current\\envs\\aclm\\lib\\site-packages\\pymultiastar\\visualization\\vis3d_helpers.py</code> <pre><code>def is_pareto_efficient(costs):\n\"\"\"\n    :param costs: An (n_points, n_costs) array\n    :return: A (n_points, ) boolean array, indicating whether each point is Pareto efficient\n    \"\"\"\n    is_efficient = np.ones(costs.shape[0], dtype=bool)\n    for i, c in enumerate(costs):\n        if is_efficient[i]:\n            is_efficient[is_efficient] = np.any(\n                costs[is_efficient] &lt;= c, axis=1)  # Remove dominated points\n    return is_efficient\n</code></pre>"},{"location":"tutorials/geoplanner/","title":"GeoPlanner - First Steps","text":""},{"location":"tutorials/simple/","title":"Starting Tutorial - First Steps","text":"<p>The MultiGoal Planner has several parameters that determine its goal and path finding behavior. Lets begin by discussing the parameters passed into PyMultiAStar constructor.</p>"},{"location":"tutorials/simple/#pymultiastar","title":"PyMultiAStar","text":"<p>A planner that will search for multiple goals with heterogenous values using a 3D A-star discrete planner.</p> <p>Parameters:</p> Name Type Description Default <code>map</code> <code>ArrayFloatMxNxK</code> <p>3D NumPy array, often called the voxel grid.                    index (i,j,k) corresponds to (y, x, z)</p> required <code>allow_diag</code> <code>bool</code> <p>Allows diagonal travel in map. Defaults to False.</p> <code>False</code> <code>map_res</code> <code>float</code> <p>The length (m) of an edge in the voxel grid. Defaults to 2.0.</p> <code>2.0</code> <code>obstacle_value</code> <code>float</code> <p>The value of an obstacle in the map. Defaults to 1.0.</p> <code>1.0</code> <code>normalizing_path_cost</code> <code>float</code> <p>The length and penalities of a path must                                     be normalized. This should generally be the                                     the longest path acceptable. Defaults to 1.0.</p> <code>1.0</code> <code>goal_weight</code> <code>float</code> <p>The weighting of the goal risk. Defaults to 0.5.</p> <code>0.5</code> <code>path_weight</code> <code>float</code> <p>The weighting of the path risk. Defaults to 0.5.</p> <code>0.5</code> <code>keep_nodes</code> <code>bool</code> <p>An optimization parameter which, if set to True,                          may result in less dynamic memory allocations if many                          goals are being searched for. Defaults to False.</p> <code>False</code> <code>path_w0</code> <code>float</code> <p>The path cost penalty multiplier when encountering                         a potential field. Defaults to 1.0.</p> <code>1.0</code>"},{"location":"tutorials/simple/#explanation","title":"Explanation","text":"<p>PyMultiAStar first requires a  map, which is a 3D NumPy array through which it searches through. We call each value in this array a Cell. To start soem</p>"}]}