{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Multi-Goal A-star","text":"<p>This repo contains code to search for multiple goals with heterogenous values using a 3D A discrete* planner. The majority of the code is written in C++ with Python bindings. This planner was used in the paper Map-Based Planning for Small Unmanned Aircraft Rooftop Landing</p> <p>What do you mean by discrete?</p> <p>The map provided should be a 3D voxel grid(i, j, k), which the planner searches. This grid is a 3D Numpy array. A cell with the value 0.0 is considered free space. A cell with the value 1.0 is considered an obstacle and cannot be traversed (this value is configurable). Values between 0.0 and 1.0 can be traversed but with a penalty (penalty weight is configurable).</p> <p>What do you mean by multiple goals with heterogenous values?</p> <p>A normal A planner has a start location and one goal. This Multi-Goal planner allows you to provide multiple goal cells each having different values. Goals with lower values are more desirable. This planner will try to find the optimal goal and path* which minimizes an objective function. It must be understood that the planner doesn't just find a path. It finds the goal and the corresponding optimal path that minimizes some larger objective function. </p> <p>What is the objective function?</p> <p>The objective function is the minimization of total risk ($r_t$), which is the combination of path risk ($r_p$) and goal risk $r_g$. In my research the goals were landing sites, therefore I called the latter landing site risk $r_l$.  Below is an excerpt from my paper that discusses this trade-off between objectives:</p> <pre><code>The figure below shows an example Pareto frontier that minimizes two objectives: landing\nsite risk and path risk. Each purple dot represents a landing site. The x-axis represents\nlanding site risk and the y-axis represents path risk to that site. The green line\nconnects five points on the Pareto frontier, the set of non-dominated landing sites\nfor which any improvement in one objective results in a negative trade-off in the other.\nEach of these five landing sites is \u201coptimal\u201d, and a quantifiable relationship between\neach objective must be constructed to select a final choice. A linear weighting scheme\nis used for these purposes\n</code></pre> <p>$$ r_t = w_l \\cdot r_l + w_p \u00b7 r_p $$</p> <p></p> <p>What precisely are these two objectives and how do they relate to the planner?</p> <p>See the following sections in the paper linked above: </p> <ul> <li>Definition of Path Cost: Section 1.3.2, Equations 1.6-1.8</li> <li>Definition of Path Risk: Section 1.5, Equation 1.17</li> <li>Definition of Landing Site (Goal) Risk: Section 1.4.4, Equation 1.9</li> </ul>"},{"location":"#install","title":"Install","text":"<p>Binary Wheels are provided for you on <code>PyPi</code>:</p> <ol> <li>Discrete Multi-Goal Planner - <code>pip install pymultiastar</code> - This exposes the class <code>PyMultiAStar</code><ol> <li>This planner only knows about Voxel Grid to traverse.</li> </ol> </li> <li>Geographically Aware Planner - <code>pip install pymultiastar[geo]</code> - This also exposes the class <code>GeoPlanner</code><ol> <li>This is a geographically aware wrapper around <code>PyMultiAStar</code>. You give a georeferenced voxel map and start conditions in GPS and landing sites in GPS and it will do the conversions between GPS to voxel cell for you. </li> </ol> </li> </ol>"},{"location":"#how-to-use","title":"How to use","text":"<p>Below are some examples:</p> <ol> <li><code>run_simple_world_3d.py</code>. Shows a very simple example of a small 3D world with multiple goals.</li> <li><code>run_maze_2d.py</code> - Demonstrates that 2D A* path planning is a subset of the Multi-Goal Planner. It loads a 2D image of a maze as a single slice in a 3D world and has only 1 goal. </li> <li><code>run_scenarios.py</code> - Shows how to use the GeoPlanner and planning in a 3D world.</li> </ol>"},{"location":"#notes","title":"Notes","text":"<p>inside pymultiastar map data - (i,j,k) is the row, column, depth</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p>"},{"location":"contributing/#environment-setup","title":"Environment setup","text":"<p>Nothing easier!</p> <p>Fork and clone the repository, then:</p> <pre><code>cd pymultiastar\npip install -e \".[dev]\"\n</code></pre>"},{"location":"contributing/#development","title":"Development","text":"<p>As usual:</p> <ol> <li>create a new branch: <code>git checkout -b feature-or-bugfix-name</code></li> <li>edit the code and/or the documentation</li> </ol> <p>Then create a pull request!</p>"},{"location":"license/","title":"License","text":"<pre><code>MIT License\n\nCopyright (c) 2023 Jeremy Castagno\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"reference/","title":"pymultiastar","text":""},{"location":"reference/#pymultiastar.__doc__","title":"<code>__doc__ = '\\n        PyMultiAstar\\n        -----------------------\\n\\n        .. currentmodule:: pymultiastar\\n\\n        .. autosummary::\\n           :toctree: _generate\\n\\n    '</code>","text":"<p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"reference/#pymultiastar.__version__","title":"<code>__version__: str = '0.0.5'</code>","text":"<p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"reference/#pymultiastar.PyMultiAStar","title":"<code>PyMultiAStar()</code>","text":"<p>         Bases: <code>pybind11_object</code></p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__module__","title":"<code>__module__ = 'pymultiastar._core'</code>","text":"<p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.normalizing_path_cost","title":"<code>normalizing_path_cost</code>  <code>property</code>","text":"<p>Gets and Sets the normalizing_path_cost used during search</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__","title":"<code>__class__(*args, **kwargs)</code>","text":"<p>         Bases: <code>type</code></p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.__annotations__","title":"<code>__annotations__ = {}</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.__bases__","title":"<code>__bases__ = (&lt;class 'type'&gt;,)</code>","text":"<p>Built-in immutable sequence.</p> <p>If no argument is given, the constructor returns an empty tuple. If iterable is specified the tuple is initialized from iterable's items.</p> <p>If the argument is a tuple, the return value is the same object.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.__basicsize__","title":"<code>__basicsize__ = 888</code>","text":"<p>int([x]) -&gt; integer int(x, base=10) -&gt; integer</p> <p>Convert a number or string to an integer, or return 0 if no arguments are given.  If x is a number, return x.int().  For floating point numbers, this truncates towards zero.</p> <p>If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base.  The literal can be preceded by '+' or '-' and be surrounded by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal.</p> <p>int('0b100', base=0) 4</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.__dictoffset__","title":"<code>__dictoffset__ = 264</code>","text":"<p>int([x]) -&gt; integer int(x, base=10) -&gt; integer</p> <p>Convert a number or string to an integer, or return 0 if no arguments are given.  If x is a number, return x.int().  For floating point numbers, this truncates towards zero.</p> <p>If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base.  The literal can be preceded by '+' or '-' and be surrounded by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal.</p> <p>int('0b100', base=0) 4</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.__flags__","title":"<code>__flags__ = 2148029952</code>","text":"<p>int([x]) -&gt; integer int(x, base=10) -&gt; integer</p> <p>Convert a number or string to an integer, or return 0 if no arguments are given.  If x is a number, return x.int().  For floating point numbers, this truncates towards zero.</p> <p>If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base.  The literal can be preceded by '+' or '-' and be surrounded by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal.</p> <p>int('0b100', base=0) 4</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.__itemsize__","title":"<code>__itemsize__ = 40</code>","text":"<p>int([x]) -&gt; integer int(x, base=10) -&gt; integer</p> <p>Convert a number or string to an integer, or return 0 if no arguments are given.  If x is a number, return x.int().  For floating point numbers, this truncates towards zero.</p> <p>If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base.  The literal can be preceded by '+' or '-' and be surrounded by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal.</p> <p>int('0b100', base=0) 4</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.__module__","title":"<code>__module__ = 'pybind11_builtins'</code>","text":"<p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.__mro__","title":"<code>__mro__ = (&lt;class 'pybind11_builtins.pybind11_type'&gt;, &lt;class 'type'&gt;, &lt;class 'object'&gt;)</code>","text":"<p>Built-in immutable sequence.</p> <p>If no argument is given, the constructor returns an empty tuple. If iterable is specified the tuple is initialized from iterable's items.</p> <p>If the argument is a tuple, the return value is the same object.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.__name__","title":"<code>__name__ = 'pybind11_type'</code>","text":"<p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.__qualname__","title":"<code>__qualname__ = 'pybind11_type'</code>","text":"<p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.__weakrefoffset__","title":"<code>__weakrefoffset__ = 368</code>","text":"<p>int([x]) -&gt; integer int(x, base=10) -&gt; integer</p> <p>Convert a number or string to an integer, or return 0 if no arguments are given.  If x is a number, return x.int().  For floating point numbers, this truncates towards zero.</p> <p>If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base.  The literal can be preceded by '+' or '-' and be surrounded by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal.</p> <p>int('0b100', base=0) 4</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.__call__","title":"<code>__call__(*args, **kwargs)</code>  <code>method descriptor</code>","text":"<p>Call self as a function.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.__delattr__","title":"<code>__delattr__(name)</code>  <code>method descriptor</code>","text":"<p>Implement delattr(self, name).</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.__dir__","title":"<code>__dir__()</code>  <code>method descriptor</code>","text":"<p>Specialized dir implementation for types.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.__eq__","title":"<code>__eq__(value)</code>  <code>method descriptor</code>","text":"<p>Return self==value.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.__format__","title":"<code>__format__(format_spec)</code>  <code>method descriptor</code>","text":"<p>Default object formatter.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.__ge__","title":"<code>__ge__(value)</code>  <code>method descriptor</code>","text":"<p>Return self&gt;=value.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.__getattribute__","title":"<code>__getattribute__(name)</code>  <code>method descriptor</code>","text":"<p>Return getattr(self, name).</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.__gt__","title":"<code>__gt__(value)</code>  <code>method descriptor</code>","text":"<p>Return self&gt;value.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.__hash__","title":"<code>__hash__()</code>  <code>method descriptor</code>","text":"<p>Return hash(self).</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.__init_subclass__","title":"<code>__init_subclass__()</code>  <code>builtin</code>","text":"<p>This method is called when a class is subclassed.</p> <p>The default implementation does nothing. It may be overridden to extend subclasses.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.__instancecheck__","title":"<code>__instancecheck__(instance)</code>  <code>method descriptor</code>","text":"<p>Check if an object is an instance.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.__le__","title":"<code>__le__(value)</code>  <code>method descriptor</code>","text":"<p>Return self&lt;=value.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.__lt__","title":"<code>__lt__(value)</code>  <code>method descriptor</code>","text":"<p>Return self&lt;value.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.__ne__","title":"<code>__ne__(value)</code>  <code>method descriptor</code>","text":"<p>Return self!=value.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.__new__","title":"<code>__new__(*args, **kwargs)</code>  <code>builtin</code>","text":"<p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.__or__","title":"<code>__or__(value)</code>  <code>method descriptor</code>","text":"<p>Return self|value.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.__prepare__","title":"<code>__prepare__()</code>  <code>builtin</code>","text":"<p>prepare() -&gt; dict used to create the namespace for the class statement</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.__reduce__","title":"<code>__reduce__()</code>  <code>method descriptor</code>","text":"<p>Helper for pickle.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.__reduce_ex__","title":"<code>__reduce_ex__(protocol)</code>  <code>method descriptor</code>","text":"<p>Helper for pickle.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.__repr__","title":"<code>__repr__()</code>  <code>method descriptor</code>","text":"<p>Return repr(self).</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.__ror__","title":"<code>__ror__(value)</code>  <code>method descriptor</code>","text":"<p>Return value|self.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.__setattr__","title":"<code>__setattr__(name, value)</code>  <code>method descriptor</code>","text":"<p>Implement setattr(self, name, value).</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.__sizeof__","title":"<code>__sizeof__()</code>  <code>method descriptor</code>","text":"<p>Return memory consumption of the type object.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.__str__","title":"<code>__str__()</code>  <code>method descriptor</code>","text":"<p>Return str(self).</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.__subclasscheck__","title":"<code>__subclasscheck__(subclass)</code>  <code>method descriptor</code>","text":"<p>Check if a class is a subclass.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.__subclasses__","title":"<code>__subclasses__()</code>  <code>method descriptor</code>","text":"<p>Return a list of immediate subclasses.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.__subclasshook__","title":"<code>__subclasshook__()</code>  <code>builtin</code>","text":"<p>Abstract classes can override this to customize issubclass().</p> <p>This is invoked early on by abc.ABCMeta.subclasscheck(). It should return True, False or NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it overrides the normal algorithm (and the outcome is cached).</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__class__.mro","title":"<code>mro()</code>  <code>method descriptor</code>","text":"<p>Return a type's method resolution order.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__delattr__","title":"<code>__delattr__(name)</code>  <code>method descriptor</code>","text":"<p>Implement delattr(self, name).</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__dir__","title":"<code>__dir__()</code>  <code>method descriptor</code>","text":"<p>Default dir() implementation.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__eq__","title":"<code>__eq__(value)</code>  <code>method descriptor</code>","text":"<p>Return self==value.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__format__","title":"<code>__format__(format_spec)</code>  <code>method descriptor</code>","text":"<p>Default object formatter.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__ge__","title":"<code>__ge__(value)</code>  <code>method descriptor</code>","text":"<p>Return self&gt;=value.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__getattribute__","title":"<code>__getattribute__(name)</code>  <code>method descriptor</code>","text":"<p>Return getattr(self, name).</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__gt__","title":"<code>__gt__(value)</code>  <code>method descriptor</code>","text":"<p>Return self&gt;value.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__hash__","title":"<code>__hash__()</code>  <code>method descriptor</code>","text":"<p>Return hash(self).</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__init_subclass__","title":"<code>__init_subclass__()</code>  <code>builtin</code>","text":"<p>This method is called when a class is subclassed.</p> <p>The default implementation does nothing. It may be overridden to extend subclasses.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__le__","title":"<code>__le__(value)</code>  <code>method descriptor</code>","text":"<p>Return self&lt;=value.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__lt__","title":"<code>__lt__(value)</code>  <code>method descriptor</code>","text":"<p>Return self&lt;value.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__ne__","title":"<code>__ne__(value)</code>  <code>method descriptor</code>","text":"<p>Return self!=value.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__new__","title":"<code>__new__(*args, **kwargs)</code>  <code>builtin</code>","text":"<p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__reduce__","title":"<code>__reduce__()</code>  <code>method descriptor</code>","text":"<p>Helper for pickle.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__reduce_ex__","title":"<code>__reduce_ex__(protocol)</code>  <code>method descriptor</code>","text":"<p>Helper for pickle.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__repr__","title":"<code>__repr__()</code>  <code>method descriptor</code>","text":"<p>Return repr(self).</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__setattr__","title":"<code>__setattr__(name, value)</code>  <code>method descriptor</code>","text":"<p>Implement setattr(self, name, value).</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__sizeof__","title":"<code>__sizeof__()</code>  <code>method descriptor</code>","text":"<p>Size of object in memory, in bytes.</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__str__","title":"<code>__str__()</code>  <code>method descriptor</code>","text":"<p>Return str(self).</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.__subclasshook__","title":"<code>__subclasshook__()</code>  <code>builtin</code>","text":"<p>Abstract classes can override this to customize issubclass().</p> <p>This is invoked early on by abc.ABCMeta.subclasscheck(). It should return True, False or NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it overrides the normal algorithm (and the outcome is cached).</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.search_multiple","title":"<code>search_multiple()</code>  <code>method descriptor</code>","text":"<p>search_multiple(self: pymultiastar._core.PyMultiAStar, start_cell: List[int[3]], goal_cells: List[Tuple[List[int[3]], float]]) -&gt; Tuple[numpy.ndarray[numpy.int32], dict]</p>"},{"location":"reference/#pymultiastar._core.PyMultiAStar.search_single","title":"<code>search_single()</code>  <code>method descriptor</code>","text":"<p>search_single(self: pymultiastar._core.PyMultiAStar, start_cell: List[int[3]], goal_cell: List[int[3]]) -&gt; Tuple[numpy.ndarray[numpy.int32], float]</p>"},{"location":"reference/types/","title":"types","text":""},{"location":"reference/geoplanner/","title":"geoplanner","text":""},{"location":"reference/geoplanner/#pymultiastar.geoplanner.GPS","title":"<code>GPS</code>  <code>dataclass</code>","text":""},{"location":"reference/geoplanner/#pymultiastar.geoplanner.types.GPS.from_gps_string","title":"<code>from_gps_string(centroid, alt=np.nan, reverse=False)</code>  <code>staticmethod</code>","text":"<p>Converts a lat-long string to a GPS object. Optionally handles height and projection</p> Source code in <code>C:\\Users\\Jerem\\scoop\\apps\\mambaforge\\current\\envs\\aclm\\lib\\site-packages\\pymultiastar\\geoplanner\\types.py</code> <pre><code>@staticmethod\ndef from_gps_string(centroid:str, alt=np.nan, reverse=False):\n\"\"\"Converts a lat-long string to a GPS object. Optionally handles height and projection\"\"\"\n    centroid_ = centroid.split(',')\n    # reverse lat,lon if necessary\n    if reverse:\n        centroid_ = centroid_[::-1] \n    gps = GPS(float(centroid_[0]), float(centroid_[1]), alt=alt)\n    return gps\n</code></pre>"},{"location":"reference/geoplanner/#pymultiastar.geoplanner.GeoPlanner","title":"<code>GeoPlanner(cost_map_fp, voxel_meta, planner_kwargs=PlannerKwargs())</code>","text":"<p>         Bases: <code>object</code></p> <p>Geographic Planner</p> <p>Parameters:</p> Name Type Description Default <code>cost_map_fp</code> <code>Path</code> <p>File path to your 3D numpy array of your cost map</p> required <code>voxel_meta</code> <code>VoxelMeta</code> <p>All meta data concerning the voxel cost_map</p> required <code>planner_kwargs</code> <code>PlannerKwargs</code> <p>Key word arguments sent to the multi-goal a-star planner. Defaults to PlannerKwargs().</p> <code>PlannerKwargs()</code> Source code in <code>C:\\Users\\Jerem\\scoop\\apps\\mambaforge\\current\\envs\\aclm\\lib\\site-packages\\pymultiastar\\geoplanner\\geoplanner.py</code> <pre><code>def __init__(\n    self,\n    cost_map_fp: Path,\n    voxel_meta: VoxelMeta,\n    planner_kwargs: PlannerKwargs = PlannerKwargs(),\n):\n\"\"\"GeoPlanner Constructor\n\n    Args:\n        cost_map_fp (Path): File path to your 3D numpy array of your cost map\n        voxel_meta (VoxelMeta): All meta data concerning the voxel cost_map\n        planner_kwargs (PlannerKwargs, optional): Key word arguments sent to the\n            multi-goal a-star planner. Defaults to PlannerKwargs().\n    \"\"\"\n    self.cost_map: ArrayFloatMxNxK = np.load(Path(cost_map_fp))\n    self.voxel_meta = voxel_meta\n    self.planner_kwargs = planner_kwargs\n\n    self.cost_map = convert_cost_map_to_float(np.load(cost_map_fp))\n    self.planner = pmstar.PyMultiAStar(self.cost_map, **planner_kwargs.to_dict())\n\n    self.transformer = Transformer.from_crs(\n        \"EPSG:4326\", voxel_meta[\"srid\"]\n    )\n</code></pre>"},{"location":"reference/geoplanner/#pymultiastar.geoplanner.geoplanner.GeoPlanner.cost_map","title":"<code>cost_map = convert_cost_map_to_float(np.load(cost_map_fp))</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>A 3D numpy array of shape (M,N,K) of type float. Our voxel map</p>"},{"location":"reference/geoplanner/#pymultiastar.geoplanner.geoplanner.GeoPlanner.planner","title":"<code>planner = pmstar.PyMultiAStar(self.cost_map, None=planner_kwargs.to_dict())</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>The multi-goal a-star planner</p>"},{"location":"reference/geoplanner/#pymultiastar.geoplanner.geoplanner.GeoPlanner.planner_kwargs","title":"<code>planner_kwargs = planner_kwargs</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>The planner keyword arguments sent to pymultiastar</p>"},{"location":"reference/geoplanner/#pymultiastar.geoplanner.geoplanner.GeoPlanner.voxel_meta","title":"<code>voxel_meta = voxel_meta</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>All metadata concerning the voxel cost_map, e.g. srid, nrows, ncols, xres, etc.</p>"},{"location":"reference/geoplanner/#pymultiastar.geoplanner.geoplanner.GeoPlanner.plan_multi_goal","title":"<code>plan_multi_goal(start_position, ls_list)</code>","text":"<p>Will find the optimal landing site and path pair from a start position</p> <p>Parameters:</p> Name Type Description Default <code>start_position</code> <code>GPS</code> <p>The start position of the aircraft</p> required <code>ls_list</code> <code>List[LandingSite]</code> <p>A list of landing sites with the associated risk</p> required <p>Returns:</p> Name Type Description <code>GeoMultiPlannerResult</code> <code>Optional[GeoMultiPlannerResult]</code> <p>The result of the planner</p> Source code in <code>C:\\Users\\Jerem\\scoop\\apps\\mambaforge\\current\\envs\\aclm\\lib\\site-packages\\pymultiastar\\geoplanner\\geoplanner.py</code> <pre><code>def plan_multi_goal(\n    self, start_position: GPS, ls_list: List[LandingSite]\n) -&gt; Optional[GeoMultiPlannerResult]:\n\"\"\"Will find the optimal landing site and path pair from a start position\n\n    Args:\n        start_position (GPS): The start position of the aircraft\n        ls_list (List[LandingSite]): A list of landing sites with the associated risk\n\n    Returns:\n        GeoMultiPlannerResult: The result of the planner\n    \"\"\"\n\n    project_start, projected_goals = prepare_planning_args_optimized(\n        start_position, ls_list, self.transformer\n    )\n    # to cell position\n    start_cell = voxel_projected_to_cell(project_start, self.voxel_meta)      \n    # logger.debug(f\"Start Cell: {start_cell}\")\n    goal_cells:List[Tuple[Tuple[int, int, int], float]] = []\n\n    # Checking on start and goal cell positions\n    bad_start = self.cost_map[start_cell[0], start_cell[1], start_cell[2]] == np.inf\n    if bad_start:\n        sc_ = start_cell[:]  # makes copy\n        start_cell = get_free_neighbor_cell(start_cell, self.cost_map)\n        if start_cell is None:\n            logger.error(\n                \"ERROR - Bad Start Cell! Start Cell: {} - {}\".format(\n                    sc_, self.cost_map[sc_[0], sc_[1], sc_[2]]\n                )\n            )\n            logger.error(\"{}\".format(start_position))\n            return None\n    # This set is used to ensure that every goal as a UNIQUE cell location in the voxel grid.\n    unique_goal_cell_set = set()\n    # In case a bad goal has been give, keep this list to mark all the valid goals (landing sites)\n    valid_landing_site_indices:List[int] = []\n    for i, (goal_pos, goal_value) in enumerate(projected_goals):\n        gc = voxel_projected_to_cell(goal_pos, self.voxel_meta)\n        bad_goal = self.cost_map[gc[0], gc[1], gc[2]] == np.inf\n        if bad_goal:\n            gc_ = gc[:]  # makes copy\n            # looks at neighbors around the cell\n            gc = get_free_neighbor_cell(gc, self.cost_map)\n            if gc is None:\n                # last chance, going vertically up only!\n                gc = get_first_free_cell_up(gc_, self.voxel_meta, self.cost_map)\n                if gc is None:\n                    # Wow this was a really bad goal.  Log the issue an review later\n                    logger.error(\n                        \"ERROR - Bad Goal Cell! Start Cell: {} - {}. Goal Cell: {} - {}\".format(\n                            start_cell,\n                            self.cost_map[\n                                start_cell[0], start_cell[1], start_cell[2]\n                            ],\n                            gc_,\n                            self.cost_map[gc_[0], gc_[1], gc_[2]],\n                        )\n                    )\n                    logger.error(\"{}, {}\".format(start_position, goal_pos))\n                    continue\n        if str(gc) not in unique_goal_cell_set:\n            unique_goal_cell_set.add(str(gc))\n            valid_landing_site_indices.append(i)\n            goal_cells.append((gc, goal_value))\n        else:\n            logger.error(\n                \"Landing site is mapped to a Map Cell that is already taken! Skipping. Index: %r, Pos: %r, Value: %r\",\n                i,\n                goal_pos,\n                goal_value,\n            )\n\n    logger.debug(f\"Start Cell: {start_cell}\")\n    logger.debug(f\"Goal Cells: {goal_cells}\")\n\n    start_time = time.perf_counter()\n    path_cells, meta = self.planner.search_multiple(\n        start_cell, goal_cells\n    )\n    elapsed_time = (time.perf_counter() - start_time) * 1000\n\n    if meta[\"goal_total_cost\"] == -1.0:\n        logger.error(\n            \"Could not find path! Starting UTM: %r; Starting Cell: %r\",\n            start_position,\n            start_cell,\n        )\n\n    logger.debug(\"Path Cost: %s \", meta[\"goal_total_cost\"])\n    # These are index coordinates! Convert to meters\n    path_projected = [\n        voxel_cell_to_projected(cell, self.voxel_meta)\n        for cell in path_cells\n    ]\n    path_projected_zero_origin = [\n        self.transform_projected_to_zero_origin(coord)\n        for coord in path_projected\n    ]\n\n\n    path_length = get_path_dist(path_projected)\n    # {'path_cost': dummy_path_risk(start_pos, goal_pos), 'path': path, 'index': index}\n    result:GeoMultiPlannerResult = {\n        \"start_position\": start_position,\n        \"path_cells\": path_cells,\n        \"path_projected\": path_projected,\n        \"path_projected_zero_origin\": path_projected_zero_origin,\n        \"path_length\": path_length,\n        \"time_ms\": elapsed_time,\n        \"valid_landing_site_indices\": valid_landing_site_indices,\n        **meta,\n    }\n    return result\n</code></pre>"},{"location":"reference/geoplanner/#pymultiastar.geoplanner.LandingSite","title":"<code>LandingSite</code>  <code>dataclass</code>","text":"<p>         Bases: <code>SuperDataClass</code></p>"},{"location":"reference/geoplanner/#pymultiastar.geoplanner.types.LandingSite.centroid","title":"<code>centroid: GPS</code>  <code>class-attribute</code>","text":"<p>The centroid of the landing site in GPS coordinates</p>"},{"location":"reference/geoplanner/#pymultiastar.geoplanner.types.LandingSite.landing_site_risk","title":"<code>landing_site_risk: float</code>  <code>class-attribute</code>","text":"<p>The normalized risk of this landing site [0-1]</p>"},{"location":"reference/geoplanner/geoplanner/","title":"geoplanner","text":""},{"location":"reference/geoplanner/geoplanner/#pymultiastar.geoplanner.geoplanner.GeoPlanner","title":"<code>GeoPlanner(cost_map_fp, voxel_meta, planner_kwargs=PlannerKwargs())</code>","text":"<p>         Bases: <code>object</code></p> <p>Geographic Planner</p> <p>Parameters:</p> Name Type Description Default <code>cost_map_fp</code> <code>Path</code> <p>File path to your 3D numpy array of your cost map</p> required <code>voxel_meta</code> <code>VoxelMeta</code> <p>All meta data concerning the voxel cost_map</p> required <code>planner_kwargs</code> <code>PlannerKwargs</code> <p>Key word arguments sent to the multi-goal a-star planner. Defaults to PlannerKwargs().</p> <code>PlannerKwargs()</code> Source code in <code>C:\\Users\\Jerem\\scoop\\apps\\mambaforge\\current\\envs\\aclm\\lib\\site-packages\\pymultiastar\\geoplanner\\geoplanner.py</code> <pre><code>def __init__(\n    self,\n    cost_map_fp: Path,\n    voxel_meta: VoxelMeta,\n    planner_kwargs: PlannerKwargs = PlannerKwargs(),\n):\n\"\"\"GeoPlanner Constructor\n\n    Args:\n        cost_map_fp (Path): File path to your 3D numpy array of your cost map\n        voxel_meta (VoxelMeta): All meta data concerning the voxel cost_map\n        planner_kwargs (PlannerKwargs, optional): Key word arguments sent to the\n            multi-goal a-star planner. Defaults to PlannerKwargs().\n    \"\"\"\n    self.cost_map: ArrayFloatMxNxK = np.load(Path(cost_map_fp))\n    self.voxel_meta = voxel_meta\n    self.planner_kwargs = planner_kwargs\n\n    self.cost_map = convert_cost_map_to_float(np.load(cost_map_fp))\n    self.planner = pmstar.PyMultiAStar(self.cost_map, **planner_kwargs.to_dict())\n\n    self.transformer = Transformer.from_crs(\n        \"EPSG:4326\", voxel_meta[\"srid\"]\n    )\n</code></pre>"},{"location":"reference/geoplanner/geoplanner/#pymultiastar.geoplanner.geoplanner.GeoPlanner.cost_map","title":"<code>cost_map = convert_cost_map_to_float(np.load(cost_map_fp))</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>A 3D numpy array of shape (M,N,K) of type float. Our voxel map</p>"},{"location":"reference/geoplanner/geoplanner/#pymultiastar.geoplanner.geoplanner.GeoPlanner.planner","title":"<code>planner = pmstar.PyMultiAStar(self.cost_map, None=planner_kwargs.to_dict())</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>The multi-goal a-star planner</p>"},{"location":"reference/geoplanner/geoplanner/#pymultiastar.geoplanner.geoplanner.GeoPlanner.planner_kwargs","title":"<code>planner_kwargs = planner_kwargs</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>The planner keyword arguments sent to pymultiastar</p>"},{"location":"reference/geoplanner/geoplanner/#pymultiastar.geoplanner.geoplanner.GeoPlanner.voxel_meta","title":"<code>voxel_meta = voxel_meta</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>All metadata concerning the voxel cost_map, e.g. srid, nrows, ncols, xres, etc.</p>"},{"location":"reference/geoplanner/geoplanner/#pymultiastar.geoplanner.geoplanner.GeoPlanner.plan_multi_goal","title":"<code>plan_multi_goal(start_position, ls_list)</code>","text":"<p>Will find the optimal landing site and path pair from a start position</p> <p>Parameters:</p> Name Type Description Default <code>start_position</code> <code>GPS</code> <p>The start position of the aircraft</p> required <code>ls_list</code> <code>List[LandingSite]</code> <p>A list of landing sites with the associated risk</p> required <p>Returns:</p> Name Type Description <code>GeoMultiPlannerResult</code> <code>Optional[GeoMultiPlannerResult]</code> <p>The result of the planner</p> Source code in <code>C:\\Users\\Jerem\\scoop\\apps\\mambaforge\\current\\envs\\aclm\\lib\\site-packages\\pymultiastar\\geoplanner\\geoplanner.py</code> <pre><code>def plan_multi_goal(\n    self, start_position: GPS, ls_list: List[LandingSite]\n) -&gt; Optional[GeoMultiPlannerResult]:\n\"\"\"Will find the optimal landing site and path pair from a start position\n\n    Args:\n        start_position (GPS): The start position of the aircraft\n        ls_list (List[LandingSite]): A list of landing sites with the associated risk\n\n    Returns:\n        GeoMultiPlannerResult: The result of the planner\n    \"\"\"\n\n    project_start, projected_goals = prepare_planning_args_optimized(\n        start_position, ls_list, self.transformer\n    )\n    # to cell position\n    start_cell = voxel_projected_to_cell(project_start, self.voxel_meta)      \n    # logger.debug(f\"Start Cell: {start_cell}\")\n    goal_cells:List[Tuple[Tuple[int, int, int], float]] = []\n\n    # Checking on start and goal cell positions\n    bad_start = self.cost_map[start_cell[0], start_cell[1], start_cell[2]] == np.inf\n    if bad_start:\n        sc_ = start_cell[:]  # makes copy\n        start_cell = get_free_neighbor_cell(start_cell, self.cost_map)\n        if start_cell is None:\n            logger.error(\n                \"ERROR - Bad Start Cell! Start Cell: {} - {}\".format(\n                    sc_, self.cost_map[sc_[0], sc_[1], sc_[2]]\n                )\n            )\n            logger.error(\"{}\".format(start_position))\n            return None\n    # This set is used to ensure that every goal as a UNIQUE cell location in the voxel grid.\n    unique_goal_cell_set = set()\n    # In case a bad goal has been give, keep this list to mark all the valid goals (landing sites)\n    valid_landing_site_indices:List[int] = []\n    for i, (goal_pos, goal_value) in enumerate(projected_goals):\n        gc = voxel_projected_to_cell(goal_pos, self.voxel_meta)\n        bad_goal = self.cost_map[gc[0], gc[1], gc[2]] == np.inf\n        if bad_goal:\n            gc_ = gc[:]  # makes copy\n            # looks at neighbors around the cell\n            gc = get_free_neighbor_cell(gc, self.cost_map)\n            if gc is None:\n                # last chance, going vertically up only!\n                gc = get_first_free_cell_up(gc_, self.voxel_meta, self.cost_map)\n                if gc is None:\n                    # Wow this was a really bad goal.  Log the issue an review later\n                    logger.error(\n                        \"ERROR - Bad Goal Cell! Start Cell: {} - {}. Goal Cell: {} - {}\".format(\n                            start_cell,\n                            self.cost_map[\n                                start_cell[0], start_cell[1], start_cell[2]\n                            ],\n                            gc_,\n                            self.cost_map[gc_[0], gc_[1], gc_[2]],\n                        )\n                    )\n                    logger.error(\"{}, {}\".format(start_position, goal_pos))\n                    continue\n        if str(gc) not in unique_goal_cell_set:\n            unique_goal_cell_set.add(str(gc))\n            valid_landing_site_indices.append(i)\n            goal_cells.append((gc, goal_value))\n        else:\n            logger.error(\n                \"Landing site is mapped to a Map Cell that is already taken! Skipping. Index: %r, Pos: %r, Value: %r\",\n                i,\n                goal_pos,\n                goal_value,\n            )\n\n    logger.debug(f\"Start Cell: {start_cell}\")\n    logger.debug(f\"Goal Cells: {goal_cells}\")\n\n    start_time = time.perf_counter()\n    path_cells, meta = self.planner.search_multiple(\n        start_cell, goal_cells\n    )\n    elapsed_time = (time.perf_counter() - start_time) * 1000\n\n    if meta[\"goal_total_cost\"] == -1.0:\n        logger.error(\n            \"Could not find path! Starting UTM: %r; Starting Cell: %r\",\n            start_position,\n            start_cell,\n        )\n\n    logger.debug(\"Path Cost: %s \", meta[\"goal_total_cost\"])\n    # These are index coordinates! Convert to meters\n    path_projected = [\n        voxel_cell_to_projected(cell, self.voxel_meta)\n        for cell in path_cells\n    ]\n    path_projected_zero_origin = [\n        self.transform_projected_to_zero_origin(coord)\n        for coord in path_projected\n    ]\n\n\n    path_length = get_path_dist(path_projected)\n    # {'path_cost': dummy_path_risk(start_pos, goal_pos), 'path': path, 'index': index}\n    result:GeoMultiPlannerResult = {\n        \"start_position\": start_position,\n        \"path_cells\": path_cells,\n        \"path_projected\": path_projected,\n        \"path_projected_zero_origin\": path_projected_zero_origin,\n        \"path_length\": path_length,\n        \"time_ms\": elapsed_time,\n        \"valid_landing_site_indices\": valid_landing_site_indices,\n        **meta,\n    }\n    return result\n</code></pre>"},{"location":"reference/geoplanner/helper/","title":"helper","text":""},{"location":"reference/geoplanner/helper/#pymultiastar.geoplanner.helper.convert_cost_map_to_float","title":"<code>convert_cost_map_to_float(cost_map, reverse_yaxis=True, normalize=True, set_max_value_to_inf=True)</code>","text":"<p>Will convert a uint8 cost map to a float32</p> <p>Note, the normal expectation is that the dimension are like so [y, x, z] Also the y-axis is growing DOWN, like an image, if this was generated from https://bitbucket.org/umich_a2sys/create-voxel/src/master/</p> <p>Parameters:</p> Name Type Description Default <code>cost_map</code> <code>np.ndarray</code> <p>Three dimenstional cost map</p> required <code>reverse_yaxis</code> <code>bool</code> <p>Will reverse y axes of the map. Defaults to True.</p> <code>True</code> <code>normalize</code> <code>bool</code> <p>Will normalize cost from 0 to 1.0. Defaults to True.</p> <code>True</code> <code>set_max_value_to_inf</code> <code>bool</code> <p>All max values will be mapped to np.inf. Defaults True.</p> <code>True</code> <p>Returns:</p> Type Description <p>np.ndarray: Your 3D cost map in float32</p> Source code in <code>C:\\Users\\Jerem\\scoop\\apps\\mambaforge\\current\\envs\\aclm\\lib\\site-packages\\pymultiastar\\geoplanner\\helper.py</code> <pre><code>def convert_cost_map_to_float(cost_map, reverse_yaxis=True, normalize=True, set_max_value_to_inf=True):\n\"\"\"Will convert a uint8 cost map to a float32\n\n\n    Note, the normal expectation is that the dimension are like so [y, x, z]\n    Also the y-axis is growing DOWN, like an image, if this was generated from https://bitbucket.org/umich_a2sys/create-voxel/src/master/\n\n\n    Args:\n        cost_map (np.ndarray): Three dimenstional cost map\n        reverse_yaxis (bool, optional): Will reverse y axes of the map. Defaults to True.\n        normalize (bool, optional): Will normalize cost from 0 to 1.0. Defaults to True.\n        set_max_value_to_inf (bool, optional): All max values will be mapped to np.inf. Defaults True.\n\n    Returns:\n        np.ndarray: Your 3D cost map in float32\n    \"\"\"\n    cost_map = cost_map.astype(np.float32)\n    if reverse_yaxis:\n        cost_map = np.flip(cost_map, 0) # reverses the y-axis\n    if normalize:\n        max_value = np.max(cost_map)\n        cost_map = cost_map / max_value # convert to float32\n    if set_max_value_to_inf:\n        cost_map[cost_map == 1.0] = np.inf\n    return cost_map\n</code></pre>"},{"location":"reference/geoplanner/helper/#pymultiastar.geoplanner.helper.prepare_planning_args_optimized","title":"<code>prepare_planning_args_optimized(start_position, ls_list, transformer)</code>","text":"<p>Prepares a list of landing sites formatted as a dictionary to be sent to a Path Planner Data is in x, y, height all in meters</p> Source code in <code>C:\\Users\\Jerem\\scoop\\apps\\mambaforge\\current\\envs\\aclm\\lib\\site-packages\\pymultiastar\\geoplanner\\helper.py</code> <pre><code>def prepare_planning_args_optimized(start_position:GPS, ls_list:List[LandingSite], transformer:Transformer):\n\"\"\"Prepares a list of landing sites formatted as a dictionary to be sent to a Path Planner\n    Data is in x, y, height all in meters\"\"\"\n    projected_position:Tuple[float, float, float] = transformer.transform(*start_position.to_array())\n    projected_goal_positions:List[Tuple[Tuple[float, float, float], float]] = [(transformer.transform(*ls.centroid.to_array()), ls.landing_site_risk)\n                        for ls in ls_list]\n\n    return projected_position, projected_goal_positions\n</code></pre>"},{"location":"reference/geoplanner/log/","title":"log","text":""},{"location":"reference/geoplanner/types/","title":"types","text":""},{"location":"reference/geoplanner/types/#pymultiastar.geoplanner.types.GPS","title":"<code>GPS</code>  <code>dataclass</code>","text":""},{"location":"reference/geoplanner/types/#pymultiastar.geoplanner.types.GPS.from_gps_string","title":"<code>from_gps_string(centroid, alt=np.nan, reverse=False)</code>  <code>staticmethod</code>","text":"<p>Converts a lat-long string to a GPS object. Optionally handles height and projection</p> Source code in <code>C:\\Users\\Jerem\\scoop\\apps\\mambaforge\\current\\envs\\aclm\\lib\\site-packages\\pymultiastar\\geoplanner\\types.py</code> <pre><code>@staticmethod\ndef from_gps_string(centroid:str, alt=np.nan, reverse=False):\n\"\"\"Converts a lat-long string to a GPS object. Optionally handles height and projection\"\"\"\n    centroid_ = centroid.split(',')\n    # reverse lat,lon if necessary\n    if reverse:\n        centroid_ = centroid_[::-1] \n    gps = GPS(float(centroid_[0]), float(centroid_[1]), alt=alt)\n    return gps\n</code></pre>"},{"location":"reference/geoplanner/types/#pymultiastar.geoplanner.types.LandingSite","title":"<code>LandingSite</code>  <code>dataclass</code>","text":"<p>         Bases: <code>SuperDataClass</code></p>"},{"location":"reference/geoplanner/types/#pymultiastar.geoplanner.types.LandingSite.centroid","title":"<code>centroid: GPS</code>  <code>class-attribute</code>","text":"<p>The centroid of the landing site in GPS coordinates</p>"},{"location":"reference/geoplanner/types/#pymultiastar.geoplanner.types.LandingSite.landing_site_risk","title":"<code>landing_site_risk: float</code>  <code>class-attribute</code>","text":"<p>The normalized risk of this landing site [0-1]</p>"},{"location":"reference/visualization/","title":"visualization","text":""},{"location":"reference/visualization/img2d_helpers/","title":"img2d_helpers","text":""},{"location":"reference/visualization/img2d_helpers/#pymultiastar.visualization.img2d_helpers.get_maze","title":"<code>get_maze(img_path, offset=3)</code>","text":"<p>This will load an image of maze into a 3D numpy array</p> <p>Parameters:</p> Name Type Description Default <code>img_path</code> <code>Path</code> <p>Path to img holding maze</p> required <code>offset</code> <code>int</code> <p>Where to offset to start and finish. Defaults to 3.</p> <code>3</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Returns a dictionary of maze data</p> Source code in <code>C:\\Users\\Jerem\\scoop\\apps\\mambaforge\\current\\envs\\aclm\\lib\\site-packages\\pymultiastar\\visualization\\img2d_helpers.py</code> <pre><code>def get_maze(img_path: Path, offset=3):\n\"\"\"This will load an image of maze into a 3D numpy array\n\n    Args:\n        img_path (Path): Path to img holding maze\n        offset (int, optional): Where to offset to start and finish. Defaults to 3.\n\n    Returns:\n        dict: Returns a dictionary of maze data\n    \"\"\"\n    img = np.asarray(Image.open(img_path))\n    logger.debug(f\"Maze name: {img_path.name}, Shape: {img.shape}\")\n    logger.debug(f\"Unique values: {np.unique(img)}\")\n    # convert to float and an empty third dimension\n    img_f = np.expand_dims((img / np.max(img)).astype(np.float32), axis=2)\n    # Best case scenario is a diagonal path, lets guess it will be 50% bigger\n    normalizing_path_cost = 1.5 * np.sqrt(img.shape[0] ** 2 + img.shape[1] ** 2)\n\n    return dict(\n        img=img,\n        map=img_f,\n        normalizing_path_cost=normalizing_path_cost,\n    )\n</code></pre>"},{"location":"reference/visualization/img2d_helpers/#pymultiastar.visualization.img2d_helpers.write_path_to_maze","title":"<code>write_path_to_maze(img_path, path, width=1)</code>","text":"<p>This will write the solution of the maze as a red line</p> <p>Parameters:</p> Name Type Description Default <code>img_path</code> <code>Path</code> <p>Original image of the maze</p> required <code>path</code> <code>np.array</code> <p>Solution path through the maze</p> required Source code in <code>C:\\Users\\Jerem\\scoop\\apps\\mambaforge\\current\\envs\\aclm\\lib\\site-packages\\pymultiastar\\visualization\\img2d_helpers.py</code> <pre><code>def write_path_to_maze(img_path: Path, path:np.array, width=1):\n\"\"\"This will write the solution of the maze as a red line\n\n    Args:\n        img_path (Path): Original image of the maze\n        path (np.array): Solution path through the maze\n    \"\"\"\n    new_img_path = img_path.with_name(img_path.stem + \"_solution.png\")\n    shutil.copy(img_path, new_img_path)\n    path = path[:, :2]\n    path = np.flip(path, axis=1) # the \"map\" has the row dimension as the first dimension (because images..)\n    path = list(map(tuple, path))\n    with Image.open(new_img_path).convert('RGB') as im:\n        draw = ImageDraw.Draw(im)\n        draw.line(path, fill=(255,0,0), width=width)\n        im.save(new_img_path)\n\n    return new_img_path\n</code></pre>"},{"location":"reference/visualization/log/","title":"log","text":""},{"location":"reference/visualization/vis3d_helpers/","title":"vis3d_helpers","text":""},{"location":"tutorials/geoplanner/","title":"GeoPlanner - First Steps","text":""},{"location":"tutorials/simple/","title":"Starting Tutorial - First Steps","text":"<p>First steps tutorial here.</p>"}]}